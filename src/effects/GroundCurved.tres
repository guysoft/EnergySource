[gd_resource type="ShaderMaterial" load_steps=7 format=3 uid="uid://dj3f4hk8m2qxp"]

[ext_resource type="Texture2D" uid="uid://bveewmtsbjo0i" path="res://textures/grid.png" id="1"]
[ext_resource type="Texture2D" uid="uid://drgu3mqyglde3" path="res://models/ground/Tiles074_2K_NormalDX.png" id="2"]
[ext_resource type="Texture2D" uid="uid://rmp2frw84n6l" path="res://models/ground/Tiles074_2K_Roughness.png" id="3"]

[sub_resource type="Shader" id="17"]
code = "// =============================================================================
// MICRO CONVEYOR BELT GROUND SHADER (with Curved World)
// =============================================================================
// 
// Same as Ground.tres but with curved world effect enabled by default.
// Used for testing horizon hiding in GroundCurveTest.tscn.
//
// DEBUG MODE:
// - Set debug_height_colors = true to visualize terrain height
// - Red = peaks, Green = middle, Blue = valleys
// =============================================================================

shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_back,diffuse_burley,specular_schlick_ggx;

// Material properties
uniform vec4 albedo : source_color;
uniform sampler2D texture_albedo : source_color;
uniform float specular;
uniform float metallic;
uniform float roughness : hint_range(0,1);
uniform float point_size : hint_range(0,128);
uniform sampler2D texture_roughness : hint_default_white;
uniform vec4 roughness_texture_channel;
uniform sampler2D texture_normal : hint_normal;
uniform float normal_scale : hint_range(-16,16);

// UV/Triplanar settings
uniform float uv1_blend_sharpness;
uniform vec3 uv1_scale;
uniform vec3 uv1_offset;
uniform vec3 uv2_scale;
uniform vec3 uv2_offset;

// Terrain displacement
uniform float displace_amount = 10.0;
uniform sampler2D noise;
uniform float emission_mult = 1.0;

// === MICRO CONVEYOR BELT SYSTEM ===
uniform float uv_offset_z = 0.0;
uniform float mesh_size_z = 100.0;

// === DEBUG MODE ===
uniform bool debug_height_colors = false;

// Curved world effect
uniform float curve_strength = 0.002;
uniform bool enable_curve = true;

// Varyings
varying vec3 uv1_triplanar_pos;
varying vec3 uv1_power_normal;
varying vec3 noise_triplanar_pos;
varying vec2 v_scrolled_uv;
varying float v_height;

vec4 triplanar_texture(sampler2D p_sampler, vec3 p_weights, vec3 p_triplanar_pos) {
	vec4 samp = vec4(0.0);
	samp += texture(p_sampler, p_triplanar_pos.xy) * p_weights.z;
	samp += texture(p_sampler, p_triplanar_pos.xz) * p_weights.y;
	samp += texture(p_sampler, p_triplanar_pos.zy * vec2(-1.0, 1.0)) * p_weights.x;
	return samp;
}

vec3 filterNormal(vec2 uv, int texelSize, float terrainSize, float _Displacement) {
	vec4 h;
	h[0] = textureLod(noise, uv + float(texelSize) * vec2(0, -1), 0).r * _Displacement;
	h[1] = textureLod(noise, uv + float(texelSize) * vec2(-1, 0), 0).r * _Displacement;
	h[2] = textureLod(noise, uv + float(texelSize) * vec2(1, 0), 0).r * _Displacement;
	h[3] = textureLod(noise, uv + float(texelSize) * vec2(0, 1), 0).r * _Displacement;

	vec3 n;
	n.z = -(h[0] - h[3]);
	n.x = (h[1] - h[2]);
	n.y = 2.0 * float(texelSize) * terrainSize;

	return normalize(n);
}

void vertex() {
	TANGENT = vec3(0.0, 0.0, -1.0) * abs(NORMAL.x);
	TANGENT += vec3(1.0, 0.0, 0.0) * abs(NORMAL.y);
	TANGENT += vec3(1.0, 0.0, 0.0) * abs(NORMAL.z);
	TANGENT = normalize(TANGENT);
	BINORMAL = vec3(0.0, 1.0, 0.0) * abs(NORMAL.x);
	BINORMAL += vec3(0.0, 0.0, -1.0) * abs(NORMAL.y);
	BINORMAL += vec3(0.0, 1.0, 0.0) * abs(NORMAL.z);
	BINORMAL = normalize(BINORMAL);
	
	uv1_power_normal = pow(abs(NORMAL), vec3(uv1_blend_sharpness));
	uv1_power_normal /= dot(uv1_power_normal, vec3(1.0));
	
	v_scrolled_uv = UV * uv1_scale.xz + vec2(0.0, -uv_offset_z);
	
	float triplanar_offset_z = uv_offset_z * mesh_size_z;
	uv1_triplanar_pos = VERTEX * uv1_scale + uv1_offset + vec3(0.0, 0.0, -triplanar_offset_z);
	noise_triplanar_pos = uv1_triplanar_pos;
	uv1_triplanar_pos *= vec3(1.0, -1.0, 1.0);
	
	float grad = abs((UV.x * 2.0) - 1.0);
	grad = smoothstep(0.0, 0.3, grad);
	
	float heightmap = texture(noise, v_scrolled_uv / uv1_scale.x).r;
	heightmap = smoothstep(0.35, 1.0, heightmap + (grad * 0.2));
	
	v_height = heightmap;
	
	vec3 modified_pos = VERTEX + vec3(0.0, heightmap * grad * displace_amount, 0.0);
	VERTEX = modified_pos;
	
	// === CURVED WORLD EFFECT ===
	if (enable_curve) {
		float dist_z = abs(VERTEX.z);
		VERTEX.y -= dist_z * dist_z * curve_strength;
	}
	
	NORMAL = filterNormal(v_scrolled_uv / uv1_scale.x, textureSize(noise, 0).x, 8.0, heightmap);
}

void fragment() {
	if (debug_height_colors) {
		vec3 valley_color = vec3(0.0, 0.0, 1.0);
		vec3 mid_color = vec3(0.0, 1.0, 0.0);
		vec3 peak_color = vec3(1.0, 0.0, 0.0);
		
		vec3 debug_color;
		if (v_height < 0.5) {
			debug_color = mix(valley_color, mid_color, v_height * 2.0);
		} else {
			debug_color = mix(mid_color, peak_color, (v_height - 0.5) * 2.0);
		}
		
		vec2 grid = fract(v_scrolled_uv);
		float line = step(0.98, grid.x) + step(0.98, grid.y);
		debug_color = mix(debug_color, vec3(1.0), line * 0.5);
		
		ALBEDO = debug_color;
		EMISSION = debug_color * 0.5;
		ROUGHNESS = 0.8;
		METALLIC = 0.0;
	} else {
		vec4 albedo_tex = triplanar_texture(texture_albedo, uv1_power_normal, uv1_triplanar_pos);
		float noise_tex = smoothstep(0.2, 0.9, triplanar_texture(noise, uv1_power_normal, noise_triplanar_pos).r);
		
		ALBEDO = albedo.rgb * albedo_tex.rgb * noise_tex;
		EMISSION = ALBEDO * emission_mult;
		METALLIC = metallic;
		float roughness_tex = dot(triplanar_texture(texture_roughness, uv1_power_normal, uv1_triplanar_pos), roughness_texture_channel);
		ROUGHNESS = roughness_tex * roughness;
		SPECULAR = specular;
		NORMAL_MAP = triplanar_texture(texture_normal, uv1_power_normal, uv1_triplanar_pos).rgb;
		NORMAL_MAP_DEPTH = normal_scale;
	}
}
"

[sub_resource type="FastNoiseLite" id="23"]

[sub_resource type="NoiseTexture2D" id="24"]
width = 1024
height = 1024
noise = SubResource("23")
seamless = true

[resource]
render_priority = 0
shader = SubResource("17")
shader_parameter/albedo = Color(1, 0.72549, 0.376471, 1)
shader_parameter/texture_albedo = ExtResource("1")
shader_parameter/specular = 0.5
shader_parameter/metallic = 1.0
shader_parameter/roughness = 1.0
shader_parameter/point_size = 1.0
shader_parameter/texture_roughness = ExtResource("3")
shader_parameter/roughness_texture_channel = Vector4(1, 0, 0, 0)
shader_parameter/texture_normal = ExtResource("2")
shader_parameter/normal_scale = 1.0
shader_parameter/uv1_blend_sharpness = 1.0
shader_parameter/uv1_scale = Vector3(4, 4, 4)
shader_parameter/uv1_offset = Vector3(0, 0, 0)
shader_parameter/uv2_scale = Vector3(1, 1, 1)
shader_parameter/uv2_offset = Vector3(0, 0, 0)
shader_parameter/displace_amount = 10.0
shader_parameter/noise = SubResource("24")
shader_parameter/emission_mult = 3.0
shader_parameter/uv_offset_z = 0.0
shader_parameter/mesh_size_z = 100.0
shader_parameter/debug_height_colors = true
shader_parameter/curve_strength = 0.002
shader_parameter/enable_curve = true
